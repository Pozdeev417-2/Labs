#include <iostream> 
#include <locale.h> 
#include <iomanip> 
#include <bitset>
#include <fstream>

int main()
{
	setlocale(LC_ALL, "Russian");
	/*
	Определение
	Приведение типов - операция по изменению способа хранения информации с исходного на требуемый с минимальной её потерей.
	Примеры:
	преобразование числа из 32 - разрядного целого знакового int в 64 - разрядное беззнаковое long int или обратно.
	Преобразование числа из целого знакового int в дробное double или обратно.
	Преобразование числа(int, double и др.) в строку.
	Явное приведение типов - приведение типов, предусмотренное программистом в коде с помощью специальных команд.
	Неявное приведение типов - приведение типов, выполняемое компилятором автоматически, в зависимости от контекста.К примеру, при передаче числа int в фукнцию, которая принимает double, компилятор определяет, что необходимо сменить тип аргумента с int на double, при этом выводит предупреждение(warning) о возможной потере точности.
	*/
	/*
	// Пример
	int int_a = 15;
	int int_b = 7;
	double double_a = 15.0;
	double double_b = 7.0;
	std::cout << "int 15/int 7" << int_a / int_b << std::endl;
	std::cout << "double 15/int 7" << double_a / int_b << std::endl;
	std::cout << "int 15/double 7" << int_a / double_b << std::endl;
	std::cout << "double 15/double 7" << double_a / double_b << std::endl;
	// -----------------------------------------------------------------------------------------------------------------------------------------------------
	// Синтаксис явного приведения типа C и C++
	// Синтаксис Си:
	// При работе с константами (типы переменных не указываются, т.к. переменных нет) принудительно задать число как дробное можно, поставив точку и дробную часть после точки:
	std::cout << 15.0/7.0 << std::endl; // результат - 2.14....
	// Явно привести константу или переменную к нужному типу в требуемом месте можно, указав нужный тип в круглых скобках перед операндом:
	int int_n=15;
	std::cout << (double)int_n/(double)7; // результат - 2.14....
	// Функции округления round() - стандартное округление к ближайшему целому, floor() - округление к меньшему, ceil() - округление к большему целому из библиотеки <math.h> в Си или <cmath> при использовании компилятора C++.
		std::cout << "*** ДЕМОНСТРАЦИЯ ОКРУГЛЕНИЯ ***" << std::endl;
		double x1 = 15.6;
		double x2 = 15.4;
		std::cout << "round(15.6) = " << round(x1) << std::endl; // 16
		std::cout << "round(15.4) = " << round(x2) << std::endl; // 15
		std::cout << "ceil(15.6) = " << ceil(x1) << std::endl; // 16
		std::cout << "ceil(15.4) = " << ceil(x2) << std::endl; // 16
		std::cout << "floor(15.6) = " << floor(x1) << std::endl; //15
		std::cout << "floor(15.4) = " << floor(x2) << std::endl; //15
	// -----------------------------------------------------------------------------------------------------------------------------------------------------
	/*
	Cинтаксис явного приведения типов C++:
	В C++ работают явные методы приведения типов Си.
	Однако рекомендуется использовать конструкцию из стандарта языка C++  static_cast<требуемый_тип>(операнд):
	*/

	/*
	int int_val=15;
	std::cout << static_cast<float>(int_val)/2; // печатает 7.5
	/*
	Задания
	Воспроизведите с комментариями в коде примеры из данного методического руководства в новом проекте Visual Studio (в составе единого solution). Сделайте резервную копию результатов в локальном и удалённом репозитории git.
	На усмотрение учащихся для более уверенного владения языком C++ сверх программы рекомендуется освоить специальные разновидности приведения типов: reinterpret_cast, dynamic_cast, const_cast.
	*/

	/*
	Файлы
	Определение
	Файл - область внешней памяти, имеющая своё собственное имя или идентификатор, выделенная для хранения массива каких-либо данных.
	Файловая система -
	способ организации хранения, доступа, удаления, изменения, именования данных на носителях информации (как правило, энергонезависимых - прим. авт.).
	иными словами - база данных, предназначенная для организации размещения и изменения файлов в массиве памяти носителя информации.
	Все операции по работе с файлами (и с другими общими ресурсами машины: порты, сетевые сокеты, драйверы оборудования, нераспределённая оперативная память) выполняются не напрямую программной, и даже не библиотечными функциями, а при посредничестве ОС. Т.к. к примеру функция fwrite не пишет на сектора жёсткого диска напрямую, а обращается к соответствующей функции ОС, которая производит требуемое действие, либо отклоняет его.
	* Если указывать имя файла без абсолютного пути, то файл будет открываться из текущего каталога
	при запуске программы в Visual Studio, она назначает текущим каталогом тот же, где лежит сам проект *.vcxproj;
	при запуске программы без Visual Studio (по двойному клику в проводнике Windows) текущим каталогом является тот же каталоге, где лежит программа;
	при запуске программы из терминала (cmd или PowerShell, или bash в Linux) текущим каталогом считается тот, который пишется на каждой строчке в самом терминале перед командой.
	Функции и примеры Си
	Работа с файлами в Си происходит с помощью функций и типов данных стандартной библиотеки языка <stdio.h> (либо <cstdio> при использовании фукций Си с компилятором C++). Логика работы с файлами в Си следующая:
	Открыть файл (запросить у ОС разрешение на действия с файлом и получить у неё интерфейс для работы с ним). Открыть файл можно
	только для чтения (для большей безопасности, если изменять его не предполагается или это может привести к сбоям). При этом функции для записи работать не будут.
	только для записи (функции для чтения работать не будут).
	для чтения и записи.
	с сохранением содержимого файла и дозаписью в конец (файл открывается для записи или чтения/записи, и при открытии текущая позиция просто вставляется в конец файла).
	с перезаписью содержимого файла (при открытии в режиме записи или чтения/записи).
	Дальнейшие действия с файлом привязаны к текущей позиции в файле (почти как курсор в тексте). При чтении/записи порции информации текущая позиция сдвигается в конец прочитанного/записанного фрагмента.
	При необходимости - сместить текущую позицию (фукнция fseek, fsetpos см. ниже)
	Закрыть файл (фактически, сообщить ОС, что работа с файлом до очередного открытия производиться не будет, и можно позволить работать с данным файлом другим программам).
	Функции и типы данных для работы с файлами на C:
	FILE - структура данных из <stdio.h> (точнее из <corecrt_wstdio.h>, подключенного внутри <stdio.h>)
	*/

	/*
	// Примеры:
	// Пример 1. Считывание и печать всего файла
	FILE* ptrFile = 0;
	fopen_s(&ptrFile, "file.txt", "rb");
	if (ptrFile == NULL) perror("Ошибка открытия файла");
	else
	{
		while (!feof(ptrFile)) // повторять цикл, пока не конец файла
		{
			char buffer[100] = { 0 };
			fgets(buffer, 100, ptrFile);
			std::cout << buffer;
		}
		fclose(ptrFile); // закрыть файл
	}
	// Пример 2. Замена (перезапись) части информации в файле
	FILE * ptrFile = fopen( "example.txt" , "w" ); // открыть для записи
	fputs( "This is sample." , ptrFile ); // записать в файл строку
	fseek( ptrFile , 9 , SEEK_SET ); // изменить позицию на 9 байт относительно начала файла
	fputs( "parta" , ptrFile ); // дописать слово в файл
	fclose ( ptrFile );
	// Пример 3. Запись строки в файл
	FILE * ptrFile = fopen("file.txt", "w"); // открыть файл file.txt в текущем каталоге в режиме только для чтения
	if (ptrFile != NULL) // проверить, удалось ли открыть файл
	{
	fputs("Пример использования функции fopen ", ptrFile); // записать строку в файл
	fclose (ptrFile);
	}
	*/






	// 2. Работа  с файламина С++

	std::fstream ifs; // создание объекта класса
	ifs.open("file1.txt", std::fstream::in | std::fstream::out);

	/*
	std::fstream::in  - только для чтения
	std::fstream::out - только для записи
	std::fstream::trunc - перезапись, если было содержимое
	std::fstream::app - запись в конец файла (фактически, курсор в конец файла)
	std::fstream::binary - открыть файл, не реагируя на \n и \r, как на разделители
	В бинарномрежиме придётся добавлять \n и \r вручную,  а в текстовом режиме
	они добавляются автоматическив в конце каждой строчки
	*/
	if (!ifs.is_open())
	{
		std::cout << "Не удалось открыть файл" << std::endl;
		return -1;
	}


	ifs << "*** ДЕМОНСТРАЦИЯ ОКРУГЛЕНИЯ ***" << std::endl;
	double x1 = 15.6;
	double x2 = 15.4;
	ifs << "round(15.6) = " << round(x1) << std::endl; // 16
	ifs << "round(15.4) = " << round(x2) << std::endl; // 15
	ifs << "ceil(15.6) = " << ceil(x1) << std::endl; // 16
	ifs << "ceil(15.4) = " << ceil(x2) << std::endl; // 16
	ifs << "floor(15.6) = " << floor(x1) << std::endl; //15
	ifs << "floor(15.4) = " << floor(x2) << std::endl; //15

	int int_val = 15;
	ifs << "static_cast<float>(int_val) / 2 = "
		<< static_cast<float>(int_val) / 2 << std::endl; // печатает 7.5
	ifs.flush(); // отдать команду принудительно слить в файл всё, что есть в буфере
	ifs.close(); // если в процессе не вызвалось ifs.flush(), сама запись в файл будет переводиться ЗДЕСЬ



	// считывание 20 символов с отступом 100 от конца файла
	char buffer[256] = { 0 };
	ifs.seekg(-100, std::fstream::end); // - "seek for get position"
	ifs.read(buffer, 100);

	// запись 100 символов с отступом 20  от начала файла
	char buffer2[100] = { 0 };
	ifs.seekp(20, std::fstream::beg); // - "seek for put position"
	ifs.write(buffer2, 100); // можно  как с cout  использовать "<<"
	ifs.close(); // если в процессе не вызвалось ifs.flush(), сама запись в файл будет переводиться ЗДЕСЬ
	
    





    std::system("pause"); // вызов функции system() из стандартной библиотеки
	return 0;
}
