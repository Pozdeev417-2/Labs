#include<locale.h> // заголовочгый файл для функции setlocale()
#include<iomanip> // заголовочный файл для cout, « и много чего еще
#include<bitset>
#include<iostream>

/*
Динамическая память(C++)
Определения и синтаксис
Класс - шаблонное описание, по которому создаются объекты.В некотором роде аналогичен типу данных - является всего лишь описанием, по которому могут быть созданы многочисленные экземпляры.
class car // игровое транспортное средство
{
    double max_speed = 120; // свойство, скорость, проинициализирована
    double fuel_consumption; // свойство, потребление топлива
    double current_speed; // свойство, скорость
    char regnumber[6] = { 0 }; // свойство, госномер
    unsigned char capacity; // свойство, число пасажиров
    accelerate(double v); // метод, увеличить скорость
    get_coordinate(/*... *//*); // метод, получить текущее положение
    /*
    change_color(/*...*//*); // метод, сменить текстуру
}
/*
Объект - экземпляр класса.В каком - то роде аналогичен переменной : можно создать переменную M типа N, и объект K класса L.
// где-то в коде:
car car_object1; // объект в стековой памяти (локальный)
car* car_object2; // указатель на объект в динамической памяти
car_object2 = new car; // создание самого объекта в динамической памяти
Методы - функции в составе класса(объявленные внутри класса).
Свойства - переменные в составе класса(объявленные внутри класса).
Чтобы воспользоваться свойствами и методами конструктора, используются операторы доступа “.” если объект локальный и “->” если объект представлен указателем :
// где-то в коде:
car_object1.max_speed = 150; // для локального объекта
car_object1.accelerate(150); // для локального объекта
car_object2->max_speed = 150; // для объекта, представленного указателем
car_object2->accelerate(150); // для объекта, представленного указателем
Чтобы изнутри конструктора сослаться на объект, который его представляет, используется указатель this.
Конструктор - метод класса, автоматически подставляемый компилятором в код без участия программиста в момент создания объекта класса.Конструктор необходим в случае
если при создании объекта нужно выполнять действия по инициализации, установлению сетевого соединения, открытию файлов, выделению динамической памяти и т.д.
если при создании объекта нужно скопировать его свойства на основе другого объекта.
Конструктор всегда по правилам C++ имеет то же имя, что и класс, и не возвращает параметров :
class car // игровое транспортное средство
{
    car() {} // конструктор по умолчанию
    car(car another_car) // копирующий конструктор
    {
        this->max_speed = another_car.max_speed;
        this->fuel_consumption = another_car.fuel_consumption;
        this->current_speed = another_car.current_speed;
        this->capacity = another_car.capacity;
    }
}
Если при уничтожении объекта нужно освобождать некоторые общие ресурсы и выполнять другие обязательные действия, объявляется метод - деструктор.Деструктор подставляется компилятором автоматически в код, когда прекращается срок жизни объекта(в конце функции, где был объявлен объект, либо в конце работы приложения).Деструктор не получает и возвращает параметров.Имя деструктора всегда равно имени класса с тильдой в начале :
class car // игровое транспортное средство
{
    ~car() // деструктор
    {
        save_to_file();
        close_file();
        delete[] block_of_memory;
        connection.close();
    }
}
Методы + свойства = поля класса.
Инкапсуляция, наследование и полиморфизм - три основные идеи(парадигмы) ООП.
Инкапсуляция - фактически, объединение данных и методов, объединённых общим смыслом, в одну конструкцию(класс), а также защита данных и механизмов конструкции от стороннего вмешательства.
Наследование - создание дочернего класса от некоего родительского и заимствование в дочернем свойств и методов родительского.Позволяет быстро обновлять / изменять кодовую базу : изменения в родительском классе автоматически применяются ко всем дочерним.Один класс можно наследовать от нескольких родительских.
Полиморфизм - простыми словами : экземпляры одного класса ведут себя по - разному.
Для ограничения доступа в стороннем коде к полям класса применяются спецификаторы доступа public, protected и private (если не применять ни один из спецификаторов, по умолчанию работает private) :
    class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    get_coordinate(/*... *//*); // метод, недоступный извне
/*
public:
    car(/*???*//*); // должен быть в public
    /*
    change_color(/*...*//*); // метод, доступный извне
    /*
    accelerate(double v); // метод, доступный извне
}
/*
После таких изменений в классе изменится поведение объекта :
// где-то в коде
car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
car_object1.change_color(“cherry”);
Пример кода модуля с классом :
#include<iostream>
#include<string>
class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    double get_coordinate() { return 0.0; } // метод, недоступный извне
    std::string color = “green”;
public:
    car() {}
    void change_color(std::string pColor); // метод, определённый СНАРУЖИ
    bool accelerate(double v) // метод, определённый ВНУТРИ класса
    {
        if (v <= this->max_speed)
        {
            this->current_speed = v;
            return true;
        }
        else
            return false;
    }
};
void car::change_color(std::string pColor) // метод, определённый СНАРУЖИ
{
    this->color = pColor;
}
int main(void)
{
    // настройка локализации и кодировки
    car car_object1; // объект в стековой памяти (локальный)
    car* car_object2; // указатель на объект в динамической памяти
    car_object2 = new car; // создание самого объекта в динамической памяти
    car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
    car_object1.change_color(“cherry”);
    // обращаться к остальным свойствам и вызывать прочие методы
    std::system(“pause”);
}
Применение
Пример 1. При электронной обработке документа(скажем, PDF или Word) удобно объединить в класс все функции по действиям с документом, а также все связанные с ним переменные.
class Document {
    Document(); // пустой конструктор
    Document(string filename); // конструктор, который при создании объекта также открывает файл
    insert_text(/*...*//*); // вставить фрагмент в документ
    /*
    insert_image(/*...*//*); // вставить изображение в  документ
    /*
    save(); // сохранить фрагмент в файл
    string contents; // строка, куда считывается  содержимое файла
    time_t creation_time; // время создания файла
}
*/

class offset {

private:// доступ ограничен

    std::string name = " Петя ";
    std::string name2 = " Вова ";
    double weight = 85;
    double growht = 190;
    std::string appraisals = "отличник.\n\n\n";
    std::string family = "живет в неполной семье";

public: // общий доступ

    Offset() { std::cout << "\t\t\tНачнём нашу игровую мини-сессию\n " << this << std::endl; }// пустой конструктор
    Offset(Offset const& headman) {} // копирующий конструктор

    void about_Петя(std::string one) {
        std::cout << "\t\t\t\tВызван метод about_Петя\n" << std::endl;
        std::cout << "\t\t\tИ так, Петя - самый лучший ученик в классе, поэтому выполнит свою работу быстрее и качественнее других" << std::endl;
        std::cout << "\t\t\t\tДля продолжения введите --)  Петя\n" << std::endl;
        std::cin >> one;
        if (one == "Петя") {
        }
    }
    
    void student_offset(std::string student, std::string one) {
        std::cout << "\t\t\t\tВызван метод offset_students\n" << std::endl;
        std::cout << "Offset - очень важная страница в жизни студентов. Правильное выполнение сулит легкое прохлждение остальных этапов, которые ждут студентов в дальнейшем." << std::endl;
        std::cout << "\t\t\t\tДля продолжения введите --)  Петя\n" << std::endl;
        std::cin >> one;
        if (one == "Петя") {
        }
    }
 ~Offset() { std::cout << "\t\t\tНадеюсь, ты усвоил много полезной информации.\n" << this << std::endl; } // Вызов деструктора
};

void two() {
    std::cout << "\t\t\t\t\t\t\tВызвана функция two\n" << std::endl;
    std::string one;
    std::string student;
    std::string name;
    std::string name2;
    int score;
    Offset student1;
	student1.about_Петя(one);
	student1.student_offset2(student, one);
    Offset* student2;
	student2 = new Dota2;
	student2->about_Петя(one);
	student2->student_offset2(student, one);

}


int main()
{

    setlocale(LC_ALL, "Russian");
    std::cout << "\t\t\t\t\t\t\tПодытог Lab6\n" << std::endl;
    std::string one;
    std::string student;
    std::string name;
    std::string name2;
    int end;
	Offset student1;
	student1.about_Петя(one);
	student1.student_offset2(student,one);
	Offset* student2;
	student2 = new Offset2;
	student2->about_Петя(one);
	student2->student_offset2(student,one);
    two();
    system("pause");
    return 0;
}
